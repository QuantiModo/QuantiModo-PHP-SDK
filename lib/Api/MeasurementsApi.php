<?php
/**
 * MeasurementsApi
 * PHP version 5
 *
 * @category Class
 * @package  QuantiModo\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * quantimodo
 *
 * We make it easy to retrieve and analyze normalized user data from a wide array of devices and applications. Check out our [docs and sdk's](https://github.com/QuantiModo/docs) or [contact us](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.112511
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace QuantiModo\Client\Api;

use \QuantiModo\Client\ApiClient;
use \QuantiModo\Client\ApiException;
use \QuantiModo\Client\Configuration;
use \QuantiModo\Client\ObjectSerializer;

/**
 * MeasurementsApi Class Doc Comment
 *
 * @category Class
 * @package  QuantiModo\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class MeasurementsApi
{
    /**
     * API Client
     *
     * @var \QuantiModo\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \QuantiModo\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\QuantiModo\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \QuantiModo\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \QuantiModo\Client\ApiClient $apiClient set the API client
     *
     * @return MeasurementsApi
     */
    public function setApiClient(\QuantiModo\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation deleteMeasurement
     *
     * Delete a measurement
     *
     * @param \QuantiModo\Client\Model\MeasurementDelete $body The startTime and variableId of the measurement to be deleted. (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function deleteMeasurement($body)
    {
        list($response) = $this->deleteMeasurementWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation deleteMeasurementWithHttpInfo
     *
     * Delete a measurement
     *
     * @param \QuantiModo\Client\Model\MeasurementDelete $body The startTime and variableId of the measurement to be deleted. (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMeasurementWithHttpInfo($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteMeasurement');
        }
        // parse inputs
        $resourcePath = "/v3/measurements/delete";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\CommonResponse',
                '/v3/measurements/delete'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\CommonResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\CommonResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getMeasurements
     *
     * Get measurements for this user
     *
     * @param string $variable_name Name of the variable you want measurements for (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param string $updated_at When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param string $connector_name Example: facebook (optional)
     * @param string $value Value of measurement (optional)
     * @param string $unit_name Example: 86400 (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $created_at When the record was first created. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param int $id Measurement id (optional)
     * @param int $grouping_width The time (in seconds) over which measurements are grouped together (optional)
     * @param string $grouping_timezone The time (in seconds) over which measurements are grouped together (optional)
     * @param bool $do_not_process Example: true (optional)
     * @param string $app_name Example: MoodiModo (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @param bool $do_not_convert Example: 1 (optional)
     * @param bool $min_max_filter Example: 1 (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\MeasurementArray
     */
    public function getMeasurements($variable_name = null, $sort = null, $limit = '100', $offset = null, $variable_category_name = null, $updated_at = null, $user_id = null, $source_name = null, $connector_name = null, $value = null, $unit_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $created_at = null, $id = null, $grouping_width = null, $grouping_timezone = null, $do_not_process = null, $app_name = null, $client_id = null, $do_not_convert = null, $min_max_filter = null)
    {
        list($response) = $this->getMeasurementsWithHttpInfo($variable_name, $sort, $limit, $offset, $variable_category_name, $updated_at, $user_id, $source_name, $connector_name, $value, $unit_name, $earliest_measurement_time, $latest_measurement_time, $created_at, $id, $grouping_width, $grouping_timezone, $do_not_process, $app_name, $client_id, $do_not_convert, $min_max_filter);
        return $response;
    }

    /**
     * Operation getMeasurementsWithHttpInfo
     *
     * Get measurements for this user
     *
     * @param string $variable_name Name of the variable you want measurements for (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param string $updated_at When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param string $connector_name Example: facebook (optional)
     * @param string $value Value of measurement (optional)
     * @param string $unit_name Example: 86400 (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $created_at When the record was first created. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param int $id Measurement id (optional)
     * @param int $grouping_width The time (in seconds) over which measurements are grouped together (optional)
     * @param string $grouping_timezone The time (in seconds) over which measurements are grouped together (optional)
     * @param bool $do_not_process Example: true (optional)
     * @param string $app_name Example: MoodiModo (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @param bool $do_not_convert Example: 1 (optional)
     * @param bool $min_max_filter Example: 1 (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\MeasurementArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMeasurementsWithHttpInfo($variable_name = null, $sort = null, $limit = '100', $offset = null, $variable_category_name = null, $updated_at = null, $user_id = null, $source_name = null, $connector_name = null, $value = null, $unit_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $created_at = null, $id = null, $grouping_width = null, $grouping_timezone = null, $do_not_process = null, $app_name = null, $client_id = null, $do_not_convert = null, $min_max_filter = null)
    {
        if (!is_null($offset) && ($offset < 0)) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MeasurementsApi.getMeasurements, must be bigger than or equal to 0.');
        }

        // parse inputs
        $resourcePath = "/v3/measurements";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($variable_name !== null) {
            $queryParams['variableName'] = $this->apiClient->getSerializer()->toQueryValue($variable_name);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = $this->apiClient->getSerializer()->toQueryValue($sort);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = $this->apiClient->getSerializer()->toQueryValue($offset);
        }
        // query params
        if ($variable_category_name !== null) {
            $queryParams['variableCategoryName'] = $this->apiClient->getSerializer()->toQueryValue($variable_category_name);
        }
        // query params
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $this->apiClient->getSerializer()->toQueryValue($updated_at);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = $this->apiClient->getSerializer()->toQueryValue($user_id);
        }
        // query params
        if ($source_name !== null) {
            $queryParams['sourceName'] = $this->apiClient->getSerializer()->toQueryValue($source_name);
        }
        // query params
        if ($connector_name !== null) {
            $queryParams['connectorName'] = $this->apiClient->getSerializer()->toQueryValue($connector_name);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = $this->apiClient->getSerializer()->toQueryValue($value);
        }
        // query params
        if ($unit_name !== null) {
            $queryParams['unitName'] = $this->apiClient->getSerializer()->toQueryValue($unit_name);
        }
        // query params
        if ($earliest_measurement_time !== null) {
            $queryParams['earliestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($earliest_measurement_time);
        }
        // query params
        if ($latest_measurement_time !== null) {
            $queryParams['latestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($latest_measurement_time);
        }
        // query params
        if ($created_at !== null) {
            $queryParams['createdAt'] = $this->apiClient->getSerializer()->toQueryValue($created_at);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = $this->apiClient->getSerializer()->toQueryValue($id);
        }
        // query params
        if ($grouping_width !== null) {
            $queryParams['groupingWidth'] = $this->apiClient->getSerializer()->toQueryValue($grouping_width);
        }
        // query params
        if ($grouping_timezone !== null) {
            $queryParams['groupingTimezone'] = $this->apiClient->getSerializer()->toQueryValue($grouping_timezone);
        }
        // query params
        if ($do_not_process !== null) {
            $queryParams['doNotProcess'] = $this->apiClient->getSerializer()->toQueryValue($do_not_process);
        }
        // query params
        if ($app_name !== null) {
            $queryParams['appName'] = $this->apiClient->getSerializer()->toQueryValue($app_name);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = $this->apiClient->getSerializer()->toQueryValue($client_id);
        }
        // query params
        if ($do_not_convert !== null) {
            $queryParams['doNotConvert'] = $this->apiClient->getSerializer()->toQueryValue($do_not_convert);
        }
        // query params
        if ($min_max_filter !== null) {
            $queryParams['minMaxFilter'] = $this->apiClient->getSerializer()->toQueryValue($min_max_filter);
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\MeasurementArray',
                '/v3/measurements'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\MeasurementArray', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\MeasurementArray', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPairs
     *
     * Get pairs of measurements for correlational analysis
     *
     * @param string $cause_variable_name Variable name of the hypothetical cause variable.  Example: Sleep Duration (optional)
     * @param string $effect_variable_name Variable name of the hypothetical effect variable.  Example: Overall Mood (optional)
     * @param string $effect_unit_name Name for the unit effect measurements to be returned in (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $cause_unit_name Name for the unit cause measurements to be returned in (optional)
     * @param string $onset_delay The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes. (optional)
     * @param string $duration_of_action The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\PairArray
     */
    public function getPairs($cause_variable_name = null, $effect_variable_name = null, $effect_unit_name = null, $user_id = null, $cause_unit_name = null, $onset_delay = null, $duration_of_action = null, $earliest_measurement_time = null, $latest_measurement_time = null, $limit = '100', $offset = null, $sort = null)
    {
        list($response) = $this->getPairsWithHttpInfo($cause_variable_name, $effect_variable_name, $effect_unit_name, $user_id, $cause_unit_name, $onset_delay, $duration_of_action, $earliest_measurement_time, $latest_measurement_time, $limit, $offset, $sort);
        return $response;
    }

    /**
     * Operation getPairsWithHttpInfo
     *
     * Get pairs of measurements for correlational analysis
     *
     * @param string $cause_variable_name Variable name of the hypothetical cause variable.  Example: Sleep Duration (optional)
     * @param string $effect_variable_name Variable name of the hypothetical effect variable.  Example: Overall Mood (optional)
     * @param string $effect_unit_name Name for the unit effect measurements to be returned in (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $cause_unit_name Name for the unit cause measurements to be returned in (optional)
     * @param string $onset_delay The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes. (optional)
     * @param string $duration_of_action The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\PairArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPairsWithHttpInfo($cause_variable_name = null, $effect_variable_name = null, $effect_unit_name = null, $user_id = null, $cause_unit_name = null, $onset_delay = null, $duration_of_action = null, $earliest_measurement_time = null, $latest_measurement_time = null, $limit = '100', $offset = null, $sort = null)
    {
        if (!is_null($offset) && ($offset < 0)) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MeasurementsApi.getPairs, must be bigger than or equal to 0.');
        }

        // parse inputs
        $resourcePath = "/v3/pairs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($cause_variable_name !== null) {
            $queryParams['causeVariableName'] = $this->apiClient->getSerializer()->toQueryValue($cause_variable_name);
        }
        // query params
        if ($effect_variable_name !== null) {
            $queryParams['effectVariableName'] = $this->apiClient->getSerializer()->toQueryValue($effect_variable_name);
        }
        // query params
        if ($effect_unit_name !== null) {
            $queryParams['effectUnitName'] = $this->apiClient->getSerializer()->toQueryValue($effect_unit_name);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = $this->apiClient->getSerializer()->toQueryValue($user_id);
        }
        // query params
        if ($cause_unit_name !== null) {
            $queryParams['causeUnitName'] = $this->apiClient->getSerializer()->toQueryValue($cause_unit_name);
        }
        // query params
        if ($onset_delay !== null) {
            $queryParams['onsetDelay'] = $this->apiClient->getSerializer()->toQueryValue($onset_delay);
        }
        // query params
        if ($duration_of_action !== null) {
            $queryParams['durationOfAction'] = $this->apiClient->getSerializer()->toQueryValue($duration_of_action);
        }
        // query params
        if ($earliest_measurement_time !== null) {
            $queryParams['earliestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($earliest_measurement_time);
        }
        // query params
        if ($latest_measurement_time !== null) {
            $queryParams['latestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($latest_measurement_time);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = $this->apiClient->getSerializer()->toQueryValue($offset);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = $this->apiClient->getSerializer()->toQueryValue($sort);
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\PairArray',
                '/v3/pairs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\PairArray', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\PairArray', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation measurementExportRequest
     *
     * Post Request for Measurements CSV
     *
     * @param float $user_id User&#39;s id (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return int
     */
    public function measurementExportRequest($user_id = null)
    {
        list($response) = $this->measurementExportRequestWithHttpInfo($user_id);
        return $response;
    }

    /**
     * Operation measurementExportRequestWithHttpInfo
     *
     * Post Request for Measurements CSV
     *
     * @param float $user_id User&#39;s id (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function measurementExportRequestWithHttpInfo($user_id = null)
    {
        // parse inputs
        $resourcePath = "/v2/measurements/exportRequest";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = $this->apiClient->getSerializer()->toQueryValue($user_id);
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'int',
                '/v2/measurements/exportRequest'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'int', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'int', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation postMeasurements
     *
     * Post a new set or update existing measurements to the database
     *
     * @param \QuantiModo\Client\Model\MeasurementSet[] $body An array of measurement sets containing measurement items you want to insert. (required)
     * @param float $user_id User&#39;s id (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\PostMeasurementsResponse
     */
    public function postMeasurements($body, $user_id = null)
    {
        list($response) = $this->postMeasurementsWithHttpInfo($body, $user_id);
        return $response;
    }

    /**
     * Operation postMeasurementsWithHttpInfo
     *
     * Post a new set or update existing measurements to the database
     *
     * @param \QuantiModo\Client\Model\MeasurementSet[] $body An array of measurement sets containing measurement items you want to insert. (required)
     * @param float $user_id User&#39;s id (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\PostMeasurementsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMeasurementsWithHttpInfo($body, $user_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling postMeasurements');
        }
        // parse inputs
        $resourcePath = "/v3/measurements/post";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = $this->apiClient->getSerializer()->toQueryValue($user_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\PostMeasurementsResponse',
                '/v3/measurements/post'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\PostMeasurementsResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\PostMeasurementsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation v3MeasurementsUpdatePost
     *
     * Update a measurement
     *
     * @param \QuantiModo\Client\Model\MeasurementUpdate $body The id as well as the new startTime, note, and/or value of the measurement to be updated (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function v3MeasurementsUpdatePost($body)
    {
        list($response) = $this->v3MeasurementsUpdatePostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation v3MeasurementsUpdatePostWithHttpInfo
     *
     * Update a measurement
     *
     * @param \QuantiModo\Client\Model\MeasurementUpdate $body The id as well as the new startTime, note, and/or value of the measurement to be updated (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v3MeasurementsUpdatePostWithHttpInfo($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling v3MeasurementsUpdatePost');
        }
        // parse inputs
        $resourcePath = "/v3/measurements/update";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\CommonResponse',
                '/v3/measurements/update'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\CommonResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\CommonResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
