<?php
/**
 * VariablesApi
 * PHP version 5
 *
 * @category Class
 * @package  QuantiModo\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * quantimodo
 *
 * We make it easy to retrieve and analyze normalized user data from a wide array of devices and applications. Check out our [docs and sdk's](https://github.com/QuantiModo/docs) or [contact us](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.112511
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace QuantiModo\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use QuantiModo\Client\ApiException;
use QuantiModo\Client\Configuration;
use QuantiModo\Client\HeaderSelector;
use QuantiModo\Client\ObjectSerializer;

/**
 * VariablesApi Class Doc Comment
 *
 * @category Class
 * @package  QuantiModo\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VariablesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteUserTag
     *
     * Delete user tag or ingredient
     *
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function deleteUserTag($tagged_variable_id = null, $tag_variable_id = null)
    {
        list($response) = $this->deleteUserTagWithHttpInfo($tagged_variable_id, $tag_variable_id);
        return $response;
    }

    /**
     * Operation deleteUserTagWithHttpInfo
     *
     * Delete user tag or ingredient
     *
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserTagWithHttpInfo($tagged_variable_id = null, $tag_variable_id = null)
    {
        $returnType = '\QuantiModo\Client\Model\CommonResponse';
        $request = $this->deleteUserTagRequest($tagged_variable_id, $tag_variable_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\QuantiModo\Client\Model\CommonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUserTagAsync
     *
     * Delete user tag or ingredient
     *
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserTagAsync($tagged_variable_id = null, $tag_variable_id = null)
    {
        return $this->deleteUserTagAsyncWithHttpInfo($tagged_variable_id, $tag_variable_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserTagAsyncWithHttpInfo
     *
     * Delete user tag or ingredient
     *
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserTagAsyncWithHttpInfo($tagged_variable_id = null, $tag_variable_id = null)
    {
        $returnType = '\QuantiModo\Client\Model\CommonResponse';
        $request = $this->deleteUserTagRequest($tagged_variable_id, $tag_variable_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUserTag'
     *
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteUserTagRequest($tagged_variable_id = null, $tag_variable_id = null)
    {

        $resourcePath = '/v3/userTags/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($tagged_variable_id !== null) {
            $queryParams['taggedVariableId'] = ObjectSerializer::toQueryValue($tagged_variable_id);
        }
        // query params
        if ($tag_variable_id !== null) {
            $queryParams['tagVariableId'] = ObjectSerializer::toQueryValue($tag_variable_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUserVariable
     *
     * Delete All Measurements For Variable
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteUserVariable($variable_id)
    {
        $this->deleteUserVariableWithHttpInfo($variable_id);
    }

    /**
     * Operation deleteUserVariableWithHttpInfo
     *
     * Delete All Measurements For Variable
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserVariableWithHttpInfo($variable_id)
    {
        $returnType = '';
        $request = $this->deleteUserVariableRequest($variable_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUserVariableAsync
     *
     * Delete All Measurements For Variable
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserVariableAsync($variable_id)
    {
        return $this->deleteUserVariableAsyncWithHttpInfo($variable_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserVariableAsyncWithHttpInfo
     *
     * Delete All Measurements For Variable
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserVariableAsyncWithHttpInfo($variable_id)
    {
        $returnType = '';
        $request = $this->deleteUserVariableRequest($variable_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUserVariable'
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteUserVariableRequest($variable_id)
    {
        // verify the required parameter 'variable_id' is set
        if ($variable_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable_id when calling deleteUserVariable'
            );
        }

        $resourcePath = '/v3/userVariables/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($variable_id)) {
            $_tempBody = $variable_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVariableCategories
     *
     * Variable categories
     *
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \QuantiModo\Client\Model\VariableCategory[]
     */
    public function getVariableCategories()
    {
        list($response) = $this->getVariableCategoriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getVariableCategoriesWithHttpInfo
     *
     * Variable categories
     *
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \QuantiModo\Client\Model\VariableCategory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVariableCategoriesWithHttpInfo()
    {
        $returnType = '\QuantiModo\Client\Model\VariableCategory[]';
        $request = $this->getVariableCategoriesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\QuantiModo\Client\Model\VariableCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVariableCategoriesAsync
     *
     * Variable categories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariableCategoriesAsync()
    {
        return $this->getVariableCategoriesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVariableCategoriesAsyncWithHttpInfo
     *
     * Variable categories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariableCategoriesAsyncWithHttpInfo()
    {
        $returnType = '\QuantiModo\Client\Model\VariableCategory[]';
        $request = $this->getVariableCategoriesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVariableCategories'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVariableCategoriesRequest()
    {

        $resourcePath = '/v3/variableCategories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVariables
     *
     * Get variables along with related user-specific analysis settings and statistics
     *
     * @param  bool $include_charts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided. (optional)
     * @param  string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param  float $user_id User&#39;s id (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param  string $updated_at When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param  string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  int $id Common variable id (optional)
     * @param  string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param  int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param  int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param  string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  string $upc UPC or other barcode scan result (optional)
     * @param  string $effect_or_cause Provided variable is the effect or cause (optional)
     * @param  string $public_effect_or_cause Ex: (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $join_variable_id Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId. (optional)
     * @param  int $parent_user_tag_variable_id Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $child_user_tag_variable_id Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $ingredient_user_tag_variable_id Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  int $ingredient_of_user_tag_variable_id Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  bool $common_only Return only public and aggregated common variable data instead of user-specific variables (optional)
     * @param  bool $user_only Return only user-specific variables and data, excluding common aggregated variable data (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     * @param  bool $include_tags Return parent, child, duplicate, and ingredient variables (optional)
     * @param  bool $recalculate Recalculate instead of using cached analysis (optional)
     * @param  int $variable_id Ex: 13 (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \QuantiModo\Client\Model\Variable[]
     */
    public function getVariables($include_charts = null, $number_of_raw_measurements = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $id = null, $last_source_name = null, $limit = '100', $offset = null, $sort = null, $include_public = null, $manual_tracking = null, $client_id = null, $upc = null, $effect_or_cause = null, $public_effect_or_cause = null, $exact_match = null, $variable_category_id = null, $include_private = null, $search_phrase = null, $synonyms = null, $tagged_variable_id = null, $tag_variable_id = null, $join_variable_id = null, $parent_user_tag_variable_id = null, $child_user_tag_variable_id = null, $ingredient_user_tag_variable_id = null, $ingredient_of_user_tag_variable_id = null, $common_only = null, $user_only = null, $platform = null, $include_tags = null, $recalculate = null, $variable_id = null)
    {
        list($response) = $this->getVariablesWithHttpInfo($include_charts, $number_of_raw_measurements, $user_id, $variable_category_name, $name, $updated_at, $source_name, $earliest_measurement_time, $latest_measurement_time, $id, $last_source_name, $limit, $offset, $sort, $include_public, $manual_tracking, $client_id, $upc, $effect_or_cause, $public_effect_or_cause, $exact_match, $variable_category_id, $include_private, $search_phrase, $synonyms, $tagged_variable_id, $tag_variable_id, $join_variable_id, $parent_user_tag_variable_id, $child_user_tag_variable_id, $ingredient_user_tag_variable_id, $ingredient_of_user_tag_variable_id, $common_only, $user_only, $platform, $include_tags, $recalculate, $variable_id);
        return $response;
    }

    /**
     * Operation getVariablesWithHttpInfo
     *
     * Get variables along with related user-specific analysis settings and statistics
     *
     * @param  bool $include_charts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided. (optional)
     * @param  string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param  float $user_id User&#39;s id (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param  string $updated_at When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param  string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  int $id Common variable id (optional)
     * @param  string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param  int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param  int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param  string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  string $upc UPC or other barcode scan result (optional)
     * @param  string $effect_or_cause Provided variable is the effect or cause (optional)
     * @param  string $public_effect_or_cause Ex: (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $join_variable_id Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId. (optional)
     * @param  int $parent_user_tag_variable_id Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $child_user_tag_variable_id Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $ingredient_user_tag_variable_id Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  int $ingredient_of_user_tag_variable_id Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  bool $common_only Return only public and aggregated common variable data instead of user-specific variables (optional)
     * @param  bool $user_only Return only user-specific variables and data, excluding common aggregated variable data (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     * @param  bool $include_tags Return parent, child, duplicate, and ingredient variables (optional)
     * @param  bool $recalculate Recalculate instead of using cached analysis (optional)
     * @param  int $variable_id Ex: 13 (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \QuantiModo\Client\Model\Variable[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVariablesWithHttpInfo($include_charts = null, $number_of_raw_measurements = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $id = null, $last_source_name = null, $limit = '100', $offset = null, $sort = null, $include_public = null, $manual_tracking = null, $client_id = null, $upc = null, $effect_or_cause = null, $public_effect_or_cause = null, $exact_match = null, $variable_category_id = null, $include_private = null, $search_phrase = null, $synonyms = null, $tagged_variable_id = null, $tag_variable_id = null, $join_variable_id = null, $parent_user_tag_variable_id = null, $child_user_tag_variable_id = null, $ingredient_user_tag_variable_id = null, $ingredient_of_user_tag_variable_id = null, $common_only = null, $user_only = null, $platform = null, $include_tags = null, $recalculate = null, $variable_id = null)
    {
        $returnType = '\QuantiModo\Client\Model\Variable[]';
        $request = $this->getVariablesRequest($include_charts, $number_of_raw_measurements, $user_id, $variable_category_name, $name, $updated_at, $source_name, $earliest_measurement_time, $latest_measurement_time, $id, $last_source_name, $limit, $offset, $sort, $include_public, $manual_tracking, $client_id, $upc, $effect_or_cause, $public_effect_or_cause, $exact_match, $variable_category_id, $include_private, $search_phrase, $synonyms, $tagged_variable_id, $tag_variable_id, $join_variable_id, $parent_user_tag_variable_id, $child_user_tag_variable_id, $ingredient_user_tag_variable_id, $ingredient_of_user_tag_variable_id, $common_only, $user_only, $platform, $include_tags, $recalculate, $variable_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\QuantiModo\Client\Model\Variable[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVariablesAsync
     *
     * Get variables along with related user-specific analysis settings and statistics
     *
     * @param  bool $include_charts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided. (optional)
     * @param  string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param  float $user_id User&#39;s id (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param  string $updated_at When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param  string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  int $id Common variable id (optional)
     * @param  string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param  int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param  int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param  string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  string $upc UPC or other barcode scan result (optional)
     * @param  string $effect_or_cause Provided variable is the effect or cause (optional)
     * @param  string $public_effect_or_cause Ex: (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $join_variable_id Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId. (optional)
     * @param  int $parent_user_tag_variable_id Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $child_user_tag_variable_id Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $ingredient_user_tag_variable_id Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  int $ingredient_of_user_tag_variable_id Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  bool $common_only Return only public and aggregated common variable data instead of user-specific variables (optional)
     * @param  bool $user_only Return only user-specific variables and data, excluding common aggregated variable data (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     * @param  bool $include_tags Return parent, child, duplicate, and ingredient variables (optional)
     * @param  bool $recalculate Recalculate instead of using cached analysis (optional)
     * @param  int $variable_id Ex: 13 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariablesAsync($include_charts = null, $number_of_raw_measurements = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $id = null, $last_source_name = null, $limit = '100', $offset = null, $sort = null, $include_public = null, $manual_tracking = null, $client_id = null, $upc = null, $effect_or_cause = null, $public_effect_or_cause = null, $exact_match = null, $variable_category_id = null, $include_private = null, $search_phrase = null, $synonyms = null, $tagged_variable_id = null, $tag_variable_id = null, $join_variable_id = null, $parent_user_tag_variable_id = null, $child_user_tag_variable_id = null, $ingredient_user_tag_variable_id = null, $ingredient_of_user_tag_variable_id = null, $common_only = null, $user_only = null, $platform = null, $include_tags = null, $recalculate = null, $variable_id = null)
    {
        return $this->getVariablesAsyncWithHttpInfo($include_charts, $number_of_raw_measurements, $user_id, $variable_category_name, $name, $updated_at, $source_name, $earliest_measurement_time, $latest_measurement_time, $id, $last_source_name, $limit, $offset, $sort, $include_public, $manual_tracking, $client_id, $upc, $effect_or_cause, $public_effect_or_cause, $exact_match, $variable_category_id, $include_private, $search_phrase, $synonyms, $tagged_variable_id, $tag_variable_id, $join_variable_id, $parent_user_tag_variable_id, $child_user_tag_variable_id, $ingredient_user_tag_variable_id, $ingredient_of_user_tag_variable_id, $common_only, $user_only, $platform, $include_tags, $recalculate, $variable_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVariablesAsyncWithHttpInfo
     *
     * Get variables along with related user-specific analysis settings and statistics
     *
     * @param  bool $include_charts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided. (optional)
     * @param  string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param  float $user_id User&#39;s id (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param  string $updated_at When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param  string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  int $id Common variable id (optional)
     * @param  string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param  int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param  int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param  string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  string $upc UPC or other barcode scan result (optional)
     * @param  string $effect_or_cause Provided variable is the effect or cause (optional)
     * @param  string $public_effect_or_cause Ex: (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $join_variable_id Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId. (optional)
     * @param  int $parent_user_tag_variable_id Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $child_user_tag_variable_id Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $ingredient_user_tag_variable_id Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  int $ingredient_of_user_tag_variable_id Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  bool $common_only Return only public and aggregated common variable data instead of user-specific variables (optional)
     * @param  bool $user_only Return only user-specific variables and data, excluding common aggregated variable data (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     * @param  bool $include_tags Return parent, child, duplicate, and ingredient variables (optional)
     * @param  bool $recalculate Recalculate instead of using cached analysis (optional)
     * @param  int $variable_id Ex: 13 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariablesAsyncWithHttpInfo($include_charts = null, $number_of_raw_measurements = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $id = null, $last_source_name = null, $limit = '100', $offset = null, $sort = null, $include_public = null, $manual_tracking = null, $client_id = null, $upc = null, $effect_or_cause = null, $public_effect_or_cause = null, $exact_match = null, $variable_category_id = null, $include_private = null, $search_phrase = null, $synonyms = null, $tagged_variable_id = null, $tag_variable_id = null, $join_variable_id = null, $parent_user_tag_variable_id = null, $child_user_tag_variable_id = null, $ingredient_user_tag_variable_id = null, $ingredient_of_user_tag_variable_id = null, $common_only = null, $user_only = null, $platform = null, $include_tags = null, $recalculate = null, $variable_id = null)
    {
        $returnType = '\QuantiModo\Client\Model\Variable[]';
        $request = $this->getVariablesRequest($include_charts, $number_of_raw_measurements, $user_id, $variable_category_name, $name, $updated_at, $source_name, $earliest_measurement_time, $latest_measurement_time, $id, $last_source_name, $limit, $offset, $sort, $include_public, $manual_tracking, $client_id, $upc, $effect_or_cause, $public_effect_or_cause, $exact_match, $variable_category_id, $include_private, $search_phrase, $synonyms, $tagged_variable_id, $tag_variable_id, $join_variable_id, $parent_user_tag_variable_id, $child_user_tag_variable_id, $ingredient_user_tag_variable_id, $ingredient_of_user_tag_variable_id, $common_only, $user_only, $platform, $include_tags, $recalculate, $variable_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVariables'
     *
     * @param  bool $include_charts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided. (optional)
     * @param  string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param  float $user_id User&#39;s id (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param  string $updated_at When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param  string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local. (optional)
     * @param  int $id Common variable id (optional)
     * @param  string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param  int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param  int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param  string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  string $upc UPC or other barcode scan result (optional)
     * @param  string $effect_or_cause Provided variable is the effect or cause (optional)
     * @param  string $public_effect_or_cause Ex: (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  int $tagged_variable_id Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $tag_variable_id Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient). (optional)
     * @param  int $join_variable_id Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId. (optional)
     * @param  int $parent_user_tag_variable_id Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $child_user_tag_variable_id Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed. (optional)
     * @param  int $ingredient_user_tag_variable_id Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  int $ingredient_of_user_tag_variable_id Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple. (optional)
     * @param  bool $common_only Return only public and aggregated common variable data instead of user-specific variables (optional)
     * @param  bool $user_only Return only user-specific variables and data, excluding common aggregated variable data (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     * @param  bool $include_tags Return parent, child, duplicate, and ingredient variables (optional)
     * @param  bool $recalculate Recalculate instead of using cached analysis (optional)
     * @param  int $variable_id Ex: 13 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVariablesRequest($include_charts = null, $number_of_raw_measurements = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $id = null, $last_source_name = null, $limit = '100', $offset = null, $sort = null, $include_public = null, $manual_tracking = null, $client_id = null, $upc = null, $effect_or_cause = null, $public_effect_or_cause = null, $exact_match = null, $variable_category_id = null, $include_private = null, $search_phrase = null, $synonyms = null, $tagged_variable_id = null, $tag_variable_id = null, $join_variable_id = null, $parent_user_tag_variable_id = null, $child_user_tag_variable_id = null, $ingredient_user_tag_variable_id = null, $ingredient_of_user_tag_variable_id = null, $common_only = null, $user_only = null, $platform = null, $include_tags = null, $recalculate = null, $variable_id = null)
    {
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling VariablesApi.getVariables, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v3/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_charts !== null) {
            $queryParams['includeCharts'] = ObjectSerializer::toQueryValue($include_charts);
        }
        // query params
        if ($number_of_raw_measurements !== null) {
            $queryParams['numberOfRawMeasurements'] = ObjectSerializer::toQueryValue($number_of_raw_measurements);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }
        // query params
        if ($variable_category_name !== null) {
            $queryParams['variableCategoryName'] = ObjectSerializer::toQueryValue($variable_category_name);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = ObjectSerializer::toQueryValue($updated_at);
        }
        // query params
        if ($source_name !== null) {
            $queryParams['sourceName'] = ObjectSerializer::toQueryValue($source_name);
        }
        // query params
        if ($earliest_measurement_time !== null) {
            $queryParams['earliestMeasurementTime'] = ObjectSerializer::toQueryValue($earliest_measurement_time);
        }
        // query params
        if ($latest_measurement_time !== null) {
            $queryParams['latestMeasurementTime'] = ObjectSerializer::toQueryValue($latest_measurement_time);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($last_source_name !== null) {
            $queryParams['lastSourceName'] = ObjectSerializer::toQueryValue($last_source_name);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($include_public !== null) {
            $queryParams['includePublic'] = ObjectSerializer::toQueryValue($include_public);
        }
        // query params
        if ($manual_tracking !== null) {
            $queryParams['manualTracking'] = ObjectSerializer::toQueryValue($manual_tracking);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($upc !== null) {
            $queryParams['upc'] = ObjectSerializer::toQueryValue($upc);
        }
        // query params
        if ($effect_or_cause !== null) {
            $queryParams['effectOrCause'] = ObjectSerializer::toQueryValue($effect_or_cause);
        }
        // query params
        if ($public_effect_or_cause !== null) {
            $queryParams['publicEffectOrCause'] = ObjectSerializer::toQueryValue($public_effect_or_cause);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($variable_category_id !== null) {
            $queryParams['variableCategoryId'] = ObjectSerializer::toQueryValue($variable_category_id);
        }
        // query params
        if ($include_private !== null) {
            $queryParams['includePrivate'] = ObjectSerializer::toQueryValue($include_private);
        }
        // query params
        if ($search_phrase !== null) {
            $queryParams['searchPhrase'] = ObjectSerializer::toQueryValue($search_phrase);
        }
        // query params
        if ($synonyms !== null) {
            $queryParams['synonyms'] = ObjectSerializer::toQueryValue($synonyms);
        }
        // query params
        if ($tagged_variable_id !== null) {
            $queryParams['taggedVariableId'] = ObjectSerializer::toQueryValue($tagged_variable_id);
        }
        // query params
        if ($tag_variable_id !== null) {
            $queryParams['tagVariableId'] = ObjectSerializer::toQueryValue($tag_variable_id);
        }
        // query params
        if ($join_variable_id !== null) {
            $queryParams['joinVariableId'] = ObjectSerializer::toQueryValue($join_variable_id);
        }
        // query params
        if ($parent_user_tag_variable_id !== null) {
            $queryParams['parentUserTagVariableId'] = ObjectSerializer::toQueryValue($parent_user_tag_variable_id);
        }
        // query params
        if ($child_user_tag_variable_id !== null) {
            $queryParams['childUserTagVariableId'] = ObjectSerializer::toQueryValue($child_user_tag_variable_id);
        }
        // query params
        if ($ingredient_user_tag_variable_id !== null) {
            $queryParams['ingredientUserTagVariableId'] = ObjectSerializer::toQueryValue($ingredient_user_tag_variable_id);
        }
        // query params
        if ($ingredient_of_user_tag_variable_id !== null) {
            $queryParams['ingredientOfUserTagVariableId'] = ObjectSerializer::toQueryValue($ingredient_of_user_tag_variable_id);
        }
        // query params
        if ($common_only !== null) {
            $queryParams['commonOnly'] = ObjectSerializer::toQueryValue($common_only);
        }
        // query params
        if ($user_only !== null) {
            $queryParams['userOnly'] = ObjectSerializer::toQueryValue($user_only);
        }
        // query params
        if ($platform !== null) {
            $queryParams['platform'] = ObjectSerializer::toQueryValue($platform);
        }
        // query params
        if ($include_tags !== null) {
            $queryParams['includeTags'] = ObjectSerializer::toQueryValue($include_tags);
        }
        // query params
        if ($recalculate !== null) {
            $queryParams['recalculate'] = ObjectSerializer::toQueryValue($recalculate);
        }
        // query params
        if ($variable_id !== null) {
            $queryParams['variableId'] = ObjectSerializer::toQueryValue($variable_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postUserTags
     *
     * Post or update user tags or ingredients
     *
     * @param  \QuantiModo\Client\Model\UserTag $body Contains the new user tag data (required)
     * @param  float $user_id User&#39;s id (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function postUserTags($body, $user_id = null)
    {
        list($response) = $this->postUserTagsWithHttpInfo($body, $user_id);
        return $response;
    }

    /**
     * Operation postUserTagsWithHttpInfo
     *
     * Post or update user tags or ingredients
     *
     * @param  \QuantiModo\Client\Model\UserTag $body Contains the new user tag data (required)
     * @param  float $user_id User&#39;s id (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUserTagsWithHttpInfo($body, $user_id = null)
    {
        $returnType = '\QuantiModo\Client\Model\CommonResponse';
        $request = $this->postUserTagsRequest($body, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\QuantiModo\Client\Model\CommonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postUserTagsAsync
     *
     * Post or update user tags or ingredients
     *
     * @param  \QuantiModo\Client\Model\UserTag $body Contains the new user tag data (required)
     * @param  float $user_id User&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserTagsAsync($body, $user_id = null)
    {
        return $this->postUserTagsAsyncWithHttpInfo($body, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postUserTagsAsyncWithHttpInfo
     *
     * Post or update user tags or ingredients
     *
     * @param  \QuantiModo\Client\Model\UserTag $body Contains the new user tag data (required)
     * @param  float $user_id User&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserTagsAsyncWithHttpInfo($body, $user_id = null)
    {
        $returnType = '\QuantiModo\Client\Model\CommonResponse';
        $request = $this->postUserTagsRequest($body, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postUserTags'
     *
     * @param  \QuantiModo\Client\Model\UserTag $body Contains the new user tag data (required)
     * @param  float $user_id User&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postUserTagsRequest($body, $user_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postUserTags'
            );
        }

        $resourcePath = '/v3/userTags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postUserVariables
     *
     * Update User Settings for a Variable
     *
     * @param  \QuantiModo\Client\Model\Variable[] $user_variables Variable user settings data (required)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function postUserVariables($user_variables, $include_private = null, $client_id = null, $include_public = null, $search_phrase = null, $exact_match = null, $manual_tracking = null, $variable_category_name = null, $variable_category_id = null, $synonyms = null, $platform = null)
    {
        list($response) = $this->postUserVariablesWithHttpInfo($user_variables, $include_private, $client_id, $include_public, $search_phrase, $exact_match, $manual_tracking, $variable_category_name, $variable_category_id, $synonyms, $platform);
        return $response;
    }

    /**
     * Operation postUserVariablesWithHttpInfo
     *
     * Update User Settings for a Variable
     *
     * @param  \QuantiModo\Client\Model\Variable[] $user_variables Variable user settings data (required)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUserVariablesWithHttpInfo($user_variables, $include_private = null, $client_id = null, $include_public = null, $search_phrase = null, $exact_match = null, $manual_tracking = null, $variable_category_name = null, $variable_category_id = null, $synonyms = null, $platform = null)
    {
        $returnType = '\QuantiModo\Client\Model\CommonResponse';
        $request = $this->postUserVariablesRequest($user_variables, $include_private, $client_id, $include_public, $search_phrase, $exact_match, $manual_tracking, $variable_category_name, $variable_category_id, $synonyms, $platform);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\QuantiModo\Client\Model\CommonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postUserVariablesAsync
     *
     * Update User Settings for a Variable
     *
     * @param  \QuantiModo\Client\Model\Variable[] $user_variables Variable user settings data (required)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserVariablesAsync($user_variables, $include_private = null, $client_id = null, $include_public = null, $search_phrase = null, $exact_match = null, $manual_tracking = null, $variable_category_name = null, $variable_category_id = null, $synonyms = null, $platform = null)
    {
        return $this->postUserVariablesAsyncWithHttpInfo($user_variables, $include_private, $client_id, $include_public, $search_phrase, $exact_match, $manual_tracking, $variable_category_name, $variable_category_id, $synonyms, $platform)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postUserVariablesAsyncWithHttpInfo
     *
     * Update User Settings for a Variable
     *
     * @param  \QuantiModo\Client\Model\Variable[] $user_variables Variable user settings data (required)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserVariablesAsyncWithHttpInfo($user_variables, $include_private = null, $client_id = null, $include_public = null, $search_phrase = null, $exact_match = null, $manual_tracking = null, $variable_category_name = null, $variable_category_id = null, $synonyms = null, $platform = null)
    {
        $returnType = '\QuantiModo\Client\Model\CommonResponse';
        $request = $this->postUserVariablesRequest($user_variables, $include_private, $client_id, $include_public, $search_phrase, $exact_match, $manual_tracking, $variable_category_name, $variable_category_id, $synonyms, $platform);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postUserVariables'
     *
     * @param  \QuantiModo\Client\Model\Variable[] $user_variables Variable user settings data (required)
     * @param  bool $include_private Include user-specific variables in results (optional)
     * @param  string $client_id Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do (optional)
     * @param  bool $include_public Include variables the user has no measurements for (optional)
     * @param  string $search_phrase Ex: %Body Fat% (optional)
     * @param  bool $exact_match Require exact match (optional)
     * @param  bool $manual_tracking Only include variables tracked manually by the user (optional)
     * @param  string $variable_category_name Limit results to a specific variable category (optional)
     * @param  int $variable_category_id Ex: 13 (optional)
     * @param  string $synonyms Ex: McDonalds hotcake (optional)
     * @param  string $platform Ex: chrome, android, ios, web (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postUserVariablesRequest($user_variables, $include_private = null, $client_id = null, $include_public = null, $search_phrase = null, $exact_match = null, $manual_tracking = null, $variable_category_name = null, $variable_category_id = null, $synonyms = null, $platform = null)
    {
        // verify the required parameter 'user_variables' is set
        if ($user_variables === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_variables when calling postUserVariables'
            );
        }

        $resourcePath = '/v3/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_private !== null) {
            $queryParams['includePrivate'] = ObjectSerializer::toQueryValue($include_private);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($include_public !== null) {
            $queryParams['includePublic'] = ObjectSerializer::toQueryValue($include_public);
        }
        // query params
        if ($search_phrase !== null) {
            $queryParams['searchPhrase'] = ObjectSerializer::toQueryValue($search_phrase);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($manual_tracking !== null) {
            $queryParams['manualTracking'] = ObjectSerializer::toQueryValue($manual_tracking);
        }
        // query params
        if ($variable_category_name !== null) {
            $queryParams['variableCategoryName'] = ObjectSerializer::toQueryValue($variable_category_name);
        }
        // query params
        if ($variable_category_id !== null) {
            $queryParams['variableCategoryId'] = ObjectSerializer::toQueryValue($variable_category_id);
        }
        // query params
        if ($synonyms !== null) {
            $queryParams['synonyms'] = ObjectSerializer::toQueryValue($synonyms);
        }
        // query params
        if ($platform !== null) {
            $queryParams['platform'] = ObjectSerializer::toQueryValue($platform);
        }


        // body params
        $_tempBody = null;
        if (isset($user_variables)) {
            $_tempBody = $user_variables;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetUserVariableSettings
     *
     * Reset user settings for a variable to defaults
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resetUserVariableSettings($variable_id)
    {
        $this->resetUserVariableSettingsWithHttpInfo($variable_id);
    }

    /**
     * Operation resetUserVariableSettingsWithHttpInfo
     *
     * Reset user settings for a variable to defaults
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetUserVariableSettingsWithHttpInfo($variable_id)
    {
        $returnType = '';
        $request = $this->resetUserVariableSettingsRequest($variable_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation resetUserVariableSettingsAsync
     *
     * Reset user settings for a variable to defaults
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetUserVariableSettingsAsync($variable_id)
    {
        return $this->resetUserVariableSettingsAsyncWithHttpInfo($variable_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetUserVariableSettingsAsyncWithHttpInfo
     *
     * Reset user settings for a variable to defaults
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetUserVariableSettingsAsyncWithHttpInfo($variable_id)
    {
        $returnType = '';
        $request = $this->resetUserVariableSettingsRequest($variable_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetUserVariableSettings'
     *
     * @param  \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resetUserVariableSettingsRequest($variable_id)
    {
        // verify the required parameter 'variable_id' is set
        if ($variable_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable_id when calling resetUserVariableSettings'
            );
        }

        $resourcePath = '/v3/userVariables/reset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($variable_id)) {
            $_tempBody = $variable_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
