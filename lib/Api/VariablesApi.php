<?php
/**
 * VariablesApi
 * PHP version 5
 *
 * @category Class
 * @package  QuantiModo\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * quantimodo
 *
 * We make it easy to retrieve and analyze normalized user data from a wide array of devices and applications. Check out our [docs and sdk's](https://github.com/QuantiModo/docs) or [contact us](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.100414
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace QuantiModo\Client\Api;

use \QuantiModo\Client\ApiClient;
use \QuantiModo\Client\ApiException;
use \QuantiModo\Client\Configuration;
use \QuantiModo\Client\ObjectSerializer;

/**
 * VariablesApi Class Doc Comment
 *
 * @category Class
 * @package  QuantiModo\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VariablesApi
{
    /**
     * API Client
     *
     * @var \QuantiModo\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \QuantiModo\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\QuantiModo\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \QuantiModo\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \QuantiModo\Client\ApiClient $apiClient set the API client
     *
     * @return VariablesApi
     */
    public function setApiClient(\QuantiModo\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation deleteUserTag
     *
     * Delete user tag or ingredient
     *
     * @param int $tagged_variable_id This is the id of the variable being tagged with an ingredient or something. (required)
     * @param int $tag_variable_id This is the id of the ingredient variable whose value is determined based on the value of the tagged variable. (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function deleteUserTag($tagged_variable_id, $tag_variable_id)
    {
        list($response) = $this->deleteUserTagWithHttpInfo($tagged_variable_id, $tag_variable_id);
        return $response;
    }

    /**
     * Operation deleteUserTagWithHttpInfo
     *
     * Delete user tag or ingredient
     *
     * @param int $tagged_variable_id This is the id of the variable being tagged with an ingredient or something. (required)
     * @param int $tag_variable_id This is the id of the ingredient variable whose value is determined based on the value of the tagged variable. (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserTagWithHttpInfo($tagged_variable_id, $tag_variable_id)
    {
        // verify the required parameter 'tagged_variable_id' is set
        if ($tagged_variable_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $tagged_variable_id when calling deleteUserTag');
        }
        // verify the required parameter 'tag_variable_id' is set
        if ($tag_variable_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $tag_variable_id when calling deleteUserTag');
        }
        // parse inputs
        $resourcePath = "/v3/userTags/delete";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($tagged_variable_id !== null) {
            $queryParams['taggedVariableId'] = $this->apiClient->getSerializer()->toQueryValue($tagged_variable_id);
        }
        // query params
        if ($tag_variable_id !== null) {
            $queryParams['tagVariableId'] = $this->apiClient->getSerializer()->toQueryValue($tag_variable_id);
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\CommonResponse',
                '/v3/userTags/delete'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\CommonResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\CommonResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteUserVariable
     *
     * Delete All Measurements For Variable
     *
     * @param \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return void
     */
    public function deleteUserVariable($variable_id)
    {
        list($response) = $this->deleteUserVariableWithHttpInfo($variable_id);
        return $response;
    }

    /**
     * Operation deleteUserVariableWithHttpInfo
     *
     * Delete All Measurements For Variable
     *
     * @param \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserVariableWithHttpInfo($variable_id)
    {
        // verify the required parameter 'variable_id' is set
        if ($variable_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $variable_id when calling deleteUserVariable');
        }
        // parse inputs
        $resourcePath = "/v3/userVariables/delete";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // body params
        $_tempBody = null;
        if (isset($variable_id)) {
            $_tempBody = $variable_id;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v3/userVariables/delete'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation getCommonVariables
     *
     * Get common variables with aggregated instead of user-specific data
     *
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param string $updated_at When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $id Common variable id (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param string $effect_or_cause Example: (optional)
     * @param string $public_effect_or_cause Example: (optional)
     * @param bool $exact_match Example: (optional)
     * @param bool $manual_tracking Example: (optional)
     * @param int $variable_category_id Example: 13 (optional)
     * @param bool $include_private Example: (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @param string $search_phrase Example: %Body Fat% (optional)
     * @param string $synonyms Example: %McDonalds hotcake% (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\CommonVariableArray
     */
    public function getCommonVariables($offset = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $number_of_raw_measurements = null, $last_source_name = null, $limit = '100', $id = null, $sort = null, $effect_or_cause = null, $public_effect_or_cause = null, $exact_match = null, $manual_tracking = null, $variable_category_id = null, $include_private = null, $client_id = null, $search_phrase = null, $synonyms = null)
    {
        list($response) = $this->getCommonVariablesWithHttpInfo($offset, $user_id, $variable_category_name, $name, $updated_at, $source_name, $earliest_measurement_time, $latest_measurement_time, $number_of_raw_measurements, $last_source_name, $limit, $id, $sort, $effect_or_cause, $public_effect_or_cause, $exact_match, $manual_tracking, $variable_category_id, $include_private, $client_id, $search_phrase, $synonyms);
        return $response;
    }

    /**
     * Operation getCommonVariablesWithHttpInfo
     *
     * Get common variables with aggregated instead of user-specific data
     *
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param string $updated_at When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $id Common variable id (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param string $effect_or_cause Example: (optional)
     * @param string $public_effect_or_cause Example: (optional)
     * @param bool $exact_match Example: (optional)
     * @param bool $manual_tracking Example: (optional)
     * @param int $variable_category_id Example: 13 (optional)
     * @param bool $include_private Example: (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @param string $search_phrase Example: %Body Fat% (optional)
     * @param string $synonyms Example: %McDonalds hotcake% (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\CommonVariableArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCommonVariablesWithHttpInfo($offset = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $number_of_raw_measurements = null, $last_source_name = null, $limit = '100', $id = null, $sort = null, $effect_or_cause = null, $public_effect_or_cause = null, $exact_match = null, $manual_tracking = null, $variable_category_id = null, $include_private = null, $client_id = null, $search_phrase = null, $synonyms = null)
    {
        if (!is_null($offset) && ($offset < 0)) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling VariablesApi.getCommonVariables, must be bigger than or equal to 0.');
        }

        // parse inputs
        $resourcePath = "/v3/public/variables";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = $this->apiClient->getSerializer()->toQueryValue($offset);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = $this->apiClient->getSerializer()->toQueryValue($user_id);
        }
        // query params
        if ($variable_category_name !== null) {
            $queryParams['variableCategoryName'] = $this->apiClient->getSerializer()->toQueryValue($variable_category_name);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = $this->apiClient->getSerializer()->toQueryValue($name);
        }
        // query params
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $this->apiClient->getSerializer()->toQueryValue($updated_at);
        }
        // query params
        if ($source_name !== null) {
            $queryParams['sourceName'] = $this->apiClient->getSerializer()->toQueryValue($source_name);
        }
        // query params
        if ($earliest_measurement_time !== null) {
            $queryParams['earliestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($earliest_measurement_time);
        }
        // query params
        if ($latest_measurement_time !== null) {
            $queryParams['latestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($latest_measurement_time);
        }
        // query params
        if ($number_of_raw_measurements !== null) {
            $queryParams['numberOfRawMeasurements'] = $this->apiClient->getSerializer()->toQueryValue($number_of_raw_measurements);
        }
        // query params
        if ($last_source_name !== null) {
            $queryParams['lastSourceName'] = $this->apiClient->getSerializer()->toQueryValue($last_source_name);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = $this->apiClient->getSerializer()->toQueryValue($id);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = $this->apiClient->getSerializer()->toQueryValue($sort);
        }
        // query params
        if ($effect_or_cause !== null) {
            $queryParams['effectOrCause'] = $this->apiClient->getSerializer()->toQueryValue($effect_or_cause);
        }
        // query params
        if ($public_effect_or_cause !== null) {
            $queryParams['publicEffectOrCause'] = $this->apiClient->getSerializer()->toQueryValue($public_effect_or_cause);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = $this->apiClient->getSerializer()->toQueryValue($exact_match);
        }
        // query params
        if ($manual_tracking !== null) {
            $queryParams['manualTracking'] = $this->apiClient->getSerializer()->toQueryValue($manual_tracking);
        }
        // query params
        if ($variable_category_id !== null) {
            $queryParams['variableCategoryId'] = $this->apiClient->getSerializer()->toQueryValue($variable_category_id);
        }
        // query params
        if ($include_private !== null) {
            $queryParams['includePrivate'] = $this->apiClient->getSerializer()->toQueryValue($include_private);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = $this->apiClient->getSerializer()->toQueryValue($client_id);
        }
        // query params
        if ($search_phrase !== null) {
            $queryParams['searchPhrase'] = $this->apiClient->getSerializer()->toQueryValue($search_phrase);
        }
        // query params
        if ($synonyms !== null) {
            $queryParams['synonyms'] = $this->apiClient->getSerializer()->toQueryValue($synonyms);
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\CommonVariableArray',
                '/v3/public/variables'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\CommonVariableArray', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\CommonVariableArray', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getUserVariables
     *
     * Get variables along with related user-specific analysis settings and statistics
     *
     * @param bool $include_charts Return highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided. (optional)
     * @param string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param string $updated_at When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param int $id Common variable id (optional)
     * @param string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param bool $include_public Example: true (optional)
     * @param bool $manual_tracking Example: (optional)
     * @param string $app_name Example: MoodiModo (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\UserVariable[]
     */
    public function getUserVariables($include_charts = null, $number_of_raw_measurements = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $id = null, $last_source_name = null, $limit = '100', $offset = null, $sort = null, $include_public = null, $manual_tracking = null, $app_name = null, $client_id = null)
    {
        list($response) = $this->getUserVariablesWithHttpInfo($include_charts, $number_of_raw_measurements, $user_id, $variable_category_name, $name, $updated_at, $source_name, $earliest_measurement_time, $latest_measurement_time, $id, $last_source_name, $limit, $offset, $sort, $include_public, $manual_tracking, $app_name, $client_id);
        return $response;
    }

    /**
     * Operation getUserVariablesWithHttpInfo
     *
     * Get variables along with related user-specific analysis settings and statistics
     *
     * @param bool $include_charts Return highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided. (optional)
     * @param string $number_of_raw_measurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity. (optional)
     * @param float $user_id User&#39;s id (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param string $name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood% (optional)
     * @param string $updated_at When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local. (optional)
     * @param string $source_name ID of the source you want measurements for (supports exact name match only) (optional)
     * @param string $earliest_measurement_time Excluded records with measurement times earlier than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param string $latest_measurement_time Excluded records with measurement times later than this value. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60;  datetime format. Time zone should be UTC and not local. (optional)
     * @param int $id Common variable id (optional)
     * @param string $last_source_name Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here (optional)
     * @param int $limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records. (optional, default to 100)
     * @param int $offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned. (optional)
     * @param string $sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order. (optional)
     * @param bool $include_public Example: true (optional)
     * @param bool $manual_tracking Example: (optional)
     * @param string $app_name Example: MoodiModo (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\UserVariable[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserVariablesWithHttpInfo($include_charts = null, $number_of_raw_measurements = null, $user_id = null, $variable_category_name = null, $name = null, $updated_at = null, $source_name = null, $earliest_measurement_time = null, $latest_measurement_time = null, $id = null, $last_source_name = null, $limit = '100', $offset = null, $sort = null, $include_public = null, $manual_tracking = null, $app_name = null, $client_id = null)
    {
        if (!is_null($offset) && ($offset < 0)) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling VariablesApi.getUserVariables, must be bigger than or equal to 0.');
        }

        // parse inputs
        $resourcePath = "/v3/userVariables";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($include_charts !== null) {
            $queryParams['includeCharts'] = $this->apiClient->getSerializer()->toQueryValue($include_charts);
        }
        // query params
        if ($number_of_raw_measurements !== null) {
            $queryParams['numberOfRawMeasurements'] = $this->apiClient->getSerializer()->toQueryValue($number_of_raw_measurements);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = $this->apiClient->getSerializer()->toQueryValue($user_id);
        }
        // query params
        if ($variable_category_name !== null) {
            $queryParams['variableCategoryName'] = $this->apiClient->getSerializer()->toQueryValue($variable_category_name);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = $this->apiClient->getSerializer()->toQueryValue($name);
        }
        // query params
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $this->apiClient->getSerializer()->toQueryValue($updated_at);
        }
        // query params
        if ($source_name !== null) {
            $queryParams['sourceName'] = $this->apiClient->getSerializer()->toQueryValue($source_name);
        }
        // query params
        if ($earliest_measurement_time !== null) {
            $queryParams['earliestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($earliest_measurement_time);
        }
        // query params
        if ($latest_measurement_time !== null) {
            $queryParams['latestMeasurementTime'] = $this->apiClient->getSerializer()->toQueryValue($latest_measurement_time);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = $this->apiClient->getSerializer()->toQueryValue($id);
        }
        // query params
        if ($last_source_name !== null) {
            $queryParams['lastSourceName'] = $this->apiClient->getSerializer()->toQueryValue($last_source_name);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = $this->apiClient->getSerializer()->toQueryValue($offset);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = $this->apiClient->getSerializer()->toQueryValue($sort);
        }
        // query params
        if ($include_public !== null) {
            $queryParams['includePublic'] = $this->apiClient->getSerializer()->toQueryValue($include_public);
        }
        // query params
        if ($manual_tracking !== null) {
            $queryParams['manualTracking'] = $this->apiClient->getSerializer()->toQueryValue($manual_tracking);
        }
        // query params
        if ($app_name !== null) {
            $queryParams['appName'] = $this->apiClient->getSerializer()->toQueryValue($app_name);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = $this->apiClient->getSerializer()->toQueryValue($client_id);
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\UserVariable[]',
                '/v3/userVariables'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\UserVariable[]', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\UserVariable[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getVariableCategories
     *
     * Variable categories
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\VariableCategory[]
     */
    public function getVariableCategories()
    {
        list($response) = $this->getVariableCategoriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getVariableCategoriesWithHttpInfo
     *
     * Variable categories
     *
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\VariableCategory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVariableCategoriesWithHttpInfo()
    {
        // parse inputs
        $resourcePath = "/v3/variableCategories";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);


        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\VariableCategory[]',
                '/v3/variableCategories'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\VariableCategory[]', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\VariableCategory[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation postUserTags
     *
     * Post or update user tags or ingredients
     *
     * @param \QuantiModo\Client\Model\UserTag $body Contains the new user tag data (required)
     * @param float $user_id User&#39;s id (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function postUserTags($body, $user_id = null)
    {
        list($response) = $this->postUserTagsWithHttpInfo($body, $user_id);
        return $response;
    }

    /**
     * Operation postUserTagsWithHttpInfo
     *
     * Post or update user tags or ingredients
     *
     * @param \QuantiModo\Client\Model\UserTag $body Contains the new user tag data (required)
     * @param float $user_id User&#39;s id (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUserTagsWithHttpInfo($body, $user_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling postUserTags');
        }
        // parse inputs
        $resourcePath = "/v3/userTags";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = $this->apiClient->getSerializer()->toQueryValue($user_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\CommonResponse',
                '/v3/userTags'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\CommonResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\CommonResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation postUserVariables
     *
     * Update User Settings for a Variable
     *
     * @param \QuantiModo\Client\Model\UserVariable[] $user_variables Variable user settings data (required)
     * @param bool $include_private Example: (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @param bool $include_public Example: true (optional)
     * @param string $search_phrase Example: %Body Fat% (optional)
     * @param string $app_name Example: MoodiModo (optional)
     * @param bool $exact_match Example: (optional)
     * @param bool $manual_tracking Example: (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param int $variable_category_id Example: 13 (optional)
     * @param string $synonyms Example: %McDonalds hotcake% (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return \QuantiModo\Client\Model\CommonResponse
     */
    public function postUserVariables($user_variables, $include_private = null, $client_id = null, $include_public = null, $search_phrase = null, $app_name = null, $exact_match = null, $manual_tracking = null, $variable_category_name = null, $variable_category_id = null, $synonyms = null)
    {
        list($response) = $this->postUserVariablesWithHttpInfo($user_variables, $include_private, $client_id, $include_public, $search_phrase, $app_name, $exact_match, $manual_tracking, $variable_category_name, $variable_category_id, $synonyms);
        return $response;
    }

    /**
     * Operation postUserVariablesWithHttpInfo
     *
     * Update User Settings for a Variable
     *
     * @param \QuantiModo\Client\Model\UserVariable[] $user_variables Variable user settings data (required)
     * @param bool $include_private Example: (optional)
     * @param string $client_id Example: oauth_test_client (optional)
     * @param bool $include_public Example: true (optional)
     * @param string $search_phrase Example: %Body Fat% (optional)
     * @param string $app_name Example: MoodiModo (optional)
     * @param bool $exact_match Example: (optional)
     * @param bool $manual_tracking Example: (optional)
     * @param string $variable_category_name Limit results to a specific variable category (optional)
     * @param int $variable_category_id Example: 13 (optional)
     * @param string $synonyms Example: %McDonalds hotcake% (optional)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of \QuantiModo\Client\Model\CommonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUserVariablesWithHttpInfo($user_variables, $include_private = null, $client_id = null, $include_public = null, $search_phrase = null, $app_name = null, $exact_match = null, $manual_tracking = null, $variable_category_name = null, $variable_category_id = null, $synonyms = null)
    {
        // verify the required parameter 'user_variables' is set
        if ($user_variables === null) {
            throw new \InvalidArgumentException('Missing the required parameter $user_variables when calling postUserVariables');
        }
        // parse inputs
        $resourcePath = "/v3/userVariables";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($include_private !== null) {
            $queryParams['includePrivate'] = $this->apiClient->getSerializer()->toQueryValue($include_private);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = $this->apiClient->getSerializer()->toQueryValue($client_id);
        }
        // query params
        if ($include_public !== null) {
            $queryParams['includePublic'] = $this->apiClient->getSerializer()->toQueryValue($include_public);
        }
        // query params
        if ($search_phrase !== null) {
            $queryParams['searchPhrase'] = $this->apiClient->getSerializer()->toQueryValue($search_phrase);
        }
        // query params
        if ($app_name !== null) {
            $queryParams['appName'] = $this->apiClient->getSerializer()->toQueryValue($app_name);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = $this->apiClient->getSerializer()->toQueryValue($exact_match);
        }
        // query params
        if ($manual_tracking !== null) {
            $queryParams['manualTracking'] = $this->apiClient->getSerializer()->toQueryValue($manual_tracking);
        }
        // query params
        if ($variable_category_name !== null) {
            $queryParams['variableCategoryName'] = $this->apiClient->getSerializer()->toQueryValue($variable_category_name);
        }
        // query params
        if ($variable_category_id !== null) {
            $queryParams['variableCategoryId'] = $this->apiClient->getSerializer()->toQueryValue($variable_category_id);
        }
        // query params
        if ($synonyms !== null) {
            $queryParams['synonyms'] = $this->apiClient->getSerializer()->toQueryValue($synonyms);
        }
        // body params
        $_tempBody = null;
        if (isset($user_variables)) {
            $_tempBody = $user_variables;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\QuantiModo\Client\Model\CommonResponse',
                '/v3/userVariables'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\QuantiModo\Client\Model\CommonResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\QuantiModo\Client\Model\CommonResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation resetUserVariableSettings
     *
     * Reset user settings for a variable to defaults
     *
     * @param \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return void
     */
    public function resetUserVariableSettings($variable_id)
    {
        list($response) = $this->resetUserVariableSettingsWithHttpInfo($variable_id);
        return $response;
    }

    /**
     * Operation resetUserVariableSettingsWithHttpInfo
     *
     * Reset user settings for a variable to defaults
     *
     * @param \QuantiModo\Client\Model\UserVariableDelete $variable_id Id of the variable whose measurements should be deleted (required)
     * @throws \QuantiModo\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetUserVariableSettingsWithHttpInfo($variable_id)
    {
        // verify the required parameter 'variable_id' is set
        if ($variable_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $variable_id when calling resetUserVariableSettings');
        }
        // parse inputs
        $resourcePath = "/v3/userVariables/reset";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // body params
        $_tempBody = null;
        if (isset($variable_id)) {
            $_tempBody = $variable_id;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('access_token');
        if (strlen($apiKey) !== 0) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v3/userVariables/reset'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }
}
